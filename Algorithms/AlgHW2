Уровень 1
1.Эффективность алгоритма оценивается по временной сложности и пространственной сложности. Временная сложность определяет, сколько времени требуется
алгоритму для выполнения в зависимости от размера входных данных.
Пространственная сложность определяет, сколько дополнительной памяти требуется алгоритму для выполнения в зависимости от размера входных данных.

2.При асимптотическом анализе учитывается поведение алгоритма при стремлении размера входных данных к бесконечности. Это позволяет оценить эффективность
алгоритма независимо от конкретных значений входных данных и фокусируется на наиболее значимых аспектах, таких как число операций или использование памяти.

3.Основные правила асимптотического анализа включают:
Игнорирование констант: Оценка алгоритма должна быть базирована на его росте при увеличении размера входных данных, а не на конкретных константах.
Оценка наихудшего случая: Обычно оценивается наихудший сценарий выполнения алгоритма, когда размер входных данных наибольший.
Использование "O-нотации": Асимптотическая сложность обозначается с помощью "O-нотации", которая позволяет указать верхнюю границу роста функции в зависимости от размера входных данных.

4.Некоторые из наиболее распространенных порядков роста асимптотических функций включают:
O(1) - постоянное время (не зависит от размера входных данных).
O(log n) - логарифмическое время (рост медленнее, чем линейный).
O(n) - линейное время (прямопропорциональное к размеру входных данных).
O(n log n) - линейно-логарифмическое время (рост быстрее линейного, но медленнее квадратичного).
O(n^2) - квадратичное время (прямо пропорциональное квадрату размера входных данных).
O(2^n) - экспоненциальное время (рост быстро увеличивается с увеличением размера входных данных).
O(n!) - факториальное время (рост самый быстрый, наиболее нежелательный).

5.Pассмотрим каждый цикл по отдельности:
Внешний цикл:
Он будет выполняться n/2 раз.
Сложность этого цикла составляет O(n).

Внутренний цикл:
Он будет выполняться (n/2) - 1 раз.
Сложность этого цикла составляет O(1).

Самый внутренний цикл:
Он будет выполняться log(n) раз.
Сложность этого цикла составляет O(log n).
Таким образом, общая сложность по времени для данного кода будет O(n) * O(1) * O(log n) = O(n log n).

Сложность по памяти:
В данном коде нет использования дополнительных структур данных или выделения дополнительной памяти, за исключением хранения переменных и вывода сообщения на экран.
Поэтому сложность по памяти будет O(1), константная.
Итак, сложность по времени составляет O(n log n), а сложность по памяти - O(1).

6.Pассмотрим каждый цикл по отдельности:

Внешний цикл:
Он будет выполняться n раз.
Сложность этого цикла составляет O(n).

Внутренний цикл:
Он будет выполняться различное количество раз в зависимости от значения переменной i.
На первой итерации он будет выполняться n раз, на второй - n/2 раз, на третьей - n/3 раз и так далее.
В среднем, этот цикл будет выполняться O(log n) раз.
Таким образом, общая сложность по времени для данного кода будет O(n) * O(log n) = O(n log n).

Сложность по памяти:
В данном коде также нет использования дополнительных структур данных или выделения дополнительной памяти, за исключением хранения переменных и вывода сообщения на экран.
Поэтому сложность по памяти будет O(1), константная.
Итак, сложность по времени составляет O(n log n), а сложность по памяти - O(1).

7.Pассмотрим данную функцию:

В данной функции используется алгоритм Евклида для нахождения наибольшего общего делителя двух чисел.

Сложность по времени:
В худшем случае, когда a и b являются взаимно простыми числами, цикл будет выполняться a + b - 1 итераций.
Следовательно, сложность этой функции по времени можно оценить как O(a + b).

Сложность по памяти:
В данной функции нет использования дополнительных структур данных или выделения дополнительной памяти, за исключением хранения переменных a и b.
Поэтому сложность по памяти будет O(1), константная.
Итак, сложность по времени составляет O(a + b), а сложность по памяти - O(1).

Уровень 2
1.Асимптотическая сложность по времени и памяти для данного кода:

Лучший случай (когда n < 5):
В этом случае выполняется только одна операция вывода строки "number < 5".
Сложность по времени и памяти является константной O(1).

Худший случай (когда n >= 5):
В этом случае выполняется цикл, который будет повторяться n раз.
Сложность по времени будет линейной, O(n), так как количество итераций цикла зависит от значения n.
Сложность по памяти также является линейной, O(n), так как для каждой итерации цикла создается новая переменная i, которая занимает постоянное количество памяти.
Итак, в лучшем случае сложность по времени и памяти составляет O(1), а в худшем случае сложность по времени и памяти составляет O(n), где n - значение аргумента функции.

2.public class Sorting {
    public static void sorting(int[] array) {
        int n = array.length;
        // Внешний цикл для проходов по массиву
        for (int i = 0; i < n - 1; i++) {
            // Внутренний цикл для сравнения и обмена элементов
            for (int j = 0; j < n - i - 1; j++) {
                // Сравниваем текущий элемент с последующим
                if (array[j] > array[j + 1]) {
                    // Обмен элементов, если текущий больше следующего
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] array = {5, 2, 8, 12, 1, 6, 4};
        System.out.println("Исходный массив: " + Arrays.toString(array));

        // Вызов метода сортировки
        bubbleSort(array);

        System.out.println("Отсортированный массив: " + Arrays.toString(array));
    }
}
В методе sorting принимается массив array, который будет отсортирован с использованием алгоритма сортировки пузырьком.
Переменная n хранит длину массива.
Внешний цикл for отвечает за проходы по массиву. Он выполняется n - 1 раз, после каждого прохода самый большой элемент уже будет на своем месте.
Внутренний цикл for сравнивает и обменивает элементы пары. Он проходит по неотсортированной части массива от начала до n - i - 1, где i - номер текущего прохода.
Если текущий элемент больше следующего, выполняется обмен элементов с использованием временной переменной temp.
В методе main создается исходный массив, который нужно отсортировать. Затем вызывается метод bubbleSort для сортировки массива.
Наконец, выводятся исходный и отсортированный массивы с помощью метода Arrays.toString.
